---
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Population Genetics and Evolutionary Biology Assignment 2

Studies of population structure are important both to understanding the evolutionary
history of our species and to studies of medical genetics and the mapping of human
disease traits. In this exercise, you will evaluate genotypic data for their fit to
Hardy-Weinberg Equilibrium and apply two common unsupervised cluster techniques to 
human polymorphism data.

### About the data

The data in Tasks 1 and 2 are from the Human Genome Diversity Project (HGDP) subsetted for a sample of
European individuals. The data were derived from publicly available single-nucleotide polymorphism (SNP) genotype data from the CEPH-Human Genome Diversity Panel (Cann et al. 2002) and input files obtained from John Novembre's page https://github.com/NovembreLab/HGDP_PopStruct_Exercise and details about the manipulation of the data are described there.

The data in Task 3 are from the 1,000 Genomes Project and are hosted on Graham Coop's website here:
https://github.com/cooplab/pophistory-tutorial.

The data and exercises below were modified after publicly available material hosted by John Novembre and Graham Coop at the above links.

### Completing your assignment

On the NYU Brightspace website, you will find an entry for Assignment 2 in the Assignment section. Please upload your completed assignment at the provided link. 

Please include your name in the filenames and inside the file of any uploads to Brightspace.

### General instructions for completing your assignment

You need to have installed CRAN packages tidyverse and smartsnp. Both can be installed with the familiar
install.packages("") syntax from your RStudio console. You then need to download the assignment2_data.zip. Before uncompressing, copy the .zip file
to a directory of your choosing.

### Task 1: Visual evaluation of fit to Hardy-Weinberg

In this task, you will evaluate by visual inspection the fit of the HGDP genotyping array data to 
Hardy-Weinberg (HW) expectations.

Begin by running this block of R code that defines a plotting function to visualize genotype frequencies by minor allele frequency.

```{r echo=TRUE, eval=FALSE}
ggplot.geno.vs.HW <- function(file,title=""){

  #read in the HW file from plink
  plink.hwe<-read.table(file,as.is=TRUE,header=TRUE)
  names(plink.hwe)<-c("CHR","SNP","TEST","A1","A2",
                      "GENO","oHET","eHET","Pval")
  counts<-sapply(plink.hwe$GENO,function(x){as.numeric(strsplit(x,"/")[[1]])})
  counts<-t(counts)
  nObs<-rowSums(counts)
  geno.freq<-counts/nObs
  MAF <- (geno.freq[,1]+.5*geno.freq[,2])
  g <- data.frame(nObs,MAF,geno.freq)
  row.names(g)<-plink.hwe$SNP.id
  names(g)<-c('nObs','MAF','p11','p12','p22')

  pivot_longer(g,cols=c(p11,p12,p22),names_to="Genotype",values_to="Genotype.Proportion") %>%
    ggplot() + 
    geom_point(aes(x = MAF,y = Genotype.Proportion, 
                                       color = Genotype),size = 0.5)+ 
    stat_function(fun=function(p) p^2, geom="line", colour='black',size=1) +
    stat_function(fun=function(p) 2*p*(1-p), geom="line", colour='black',size=1) +
    stat_function(fun=function(p) (1-p)^2, geom="line", colour='black',size=1) +
    scale_color_manual(values = c("#E69F00","#009E73","#0072B2"))
}
```

Now run the function by providing as input the path to file "H938_Euro.LDprune.hwe" file in the 
assignment2 data pack. Note, if you set your working directory (?setwd) to the directory with the data files then you do not need to specify a path to the data files in this exercise.

```{r echo=TRUE, eval=FALSE}
library(tidyverse)
ggplot.geno.vs.HW("H938_Euro.LDprune.hwe")
```

#### Questions

Q1.1a Consider a biallelic SNP with minor allele frequency of 0.2. What is the frequency
of the "major" allele at this locus? (1 point)

Q1.1b What is the expected frequency of the homozygous genotype for the minor 
allele (assuming Hardy-Weinberg equilibrium) (2 points)?

Q1.1c What is the expected frequency of homozygotes for the "major" allele? (2 points)

Q1.2 Now using the plot you created above to assist you, identify the color of the genotypes associated
the (a) heterozygotes, (b) homozygote for minor allele, and (c) homozygote for major allele (6 points)

heterozygote color:
homozygote for minor allele color:
homozygote for major allele color:

Q1.3 Do the observed genotypic frequencies (i.e., points) roughly follow HWE expectations
 (black lines) in the HGDP data? (1 point)

Q1.4. There are a large group of points with a deficit of heterozygotes (relative to HWE expetations). 
Why might this be? (3 points)


### Task 2: ADMIXTURE analysis of European data from the HGDP

Unsupervised clustering with software such as STRUCTURE or ADMIXTURE are common approaches
to identifying both population structure and admixture between populations. Here you will 
plot data from pre-computed Q matrices produced by running ADMIXTURE at K=6 and K=8.

Begin by modifying as necessary the path to the following data files:

```{r echo=TRUE, eval=FALSE}
clst_file = "Euro.clst.txt"
fam_file = "H938_Euro.LDprune.fam"
q_file = "H938_Euro.LDprune.8.Q"
```

Read the files into tibbles.

```{r echo=TRUE, eval=FALSE}
fam.tbl_df <- read_delim(fam_file,col_names = F,delim = " ")
names(fam.tbl_df) <- c("num","sample","X3","X4","X5","X6")
clst.tbl_df <- read_delim(clst_file,col_names = F,delim = " ")
names(clst.tbl_df) <- c("num","sample","pop")
```

The only data wrangling we need to do to plot the Q matrix data (i.e., admixture proportions) is
to add the sample identifiers (from the .fam file) and their geographic origins (Euro.clst.txt file)
to the Q matrix. That way we can group the samples by their geographic/ethnic origin in the admixture diagram.

Lets use the inner_join function to merge the two tibbles with sample and population origin information
while preserving the sample order in the file (which is the same order as the samples in the Q matrix):

```{r echo=TRUE, eval=FALSE}
sample2pop.tbl_df <- inner_join(fam.tbl_df,clst.tbl_df, by = "sample") %>%
  select(sample,pop)

# Throw error if order of ids not the same in .fam file and sample2pop.tbl_df
if( sum(sample2pop.tbl_df$sample != fam.tbl_df$sample) != 0) stop("_ERROR_")
```

Now lets read the Q matrix for K=8 and "bind" it the sample information (in sample2pop.tbl_df) using
the bind_cols function.

```{r echo=TRUE, eval=FALSE}
# Read the Q matrix into a tibble
q8.tbl_df <- read_delim(q_file,col_names = F,delim = " ")

# Bind sample id and population columns to left side of Q matrix
q8.tbl_df <- bind_cols(sample2pop.tbl_df,q8.tbl_df)
```

Now transform the K=8 data into long format with the familiar pivot_longer function

```{r echo=TRUE, eval=FALSE}
q8.long.tbl_df <- q8.tbl_df %>%
                  pivot_longer(cols = c(-sample,-pop), names_to = 'group', values_to = 'fraction')

# View the original data
q8.tbl_df

# View the data after pivoting
q8.long.tbl_df
```

Now lets plot the results grouping samples by their geographic origin using ggplot facetting as the 
mechanism to group samples. Note that the 8 RGB color definitions correspond to the 8 K values. If you would like to devise your own plotting function to go about this differently, feel free to do so.

```{r echo=TRUE, eval=FALSE}
q8.long.tbl_df %>%
ggplot(aes(x=sample,y=fraction,fill=group)) + geom_col(color = "gray", size = 0.1) +
  facet_grid(~ pop,space = "free_x", scales = "free_x") +
  scale_fill_manual(values = c("#56B4E9","#0072B2","#D55E00","#009E73","#E69F00","#F0E442","#CC79A7","#999999")) +
  theme_bw() +
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        axis.text.x = element_text(angle = 90,size = 4))
```

#### Questions

Q2.1. Are individuals from the population isolates (Adygei, French_Basque, Orcadian, and Sardinian) inferred to have distinct ancestral populations? Explain (3 points)
  
Q2.2.  Are the Tuscan and North_Italian individuals completely distinguished as being from distinct populations?  How about these two relative to French? Explain. (3 points)
  
Q2.3.  Which two sampled populations seems to have the most internal population structure? Explain. (3 points)


Q2.4a. Now rerun the analysis with K = 6 (using input file H938_Euro.LDprune.6.Q) and attach the figure
to your homework (8 points) 

Please note, the colors will not necessarily correspond to the same groups also present at K=8 (because
ADMIXTURE has no knowledge of the cluster number assignments from a separate run of the program). You may therefore wish to adjust the colors so that unadmixed groups at K=6 represent the same unadmixed groups at K=8. The colors are defined in the scale_fill_manual argument and are assigned in alphabetical order of the populations (e.e., RGB color code "#56B4E9" corresponds to ancestral cluster "X1","#0072B2" to ancestral cluster "X2" etc.)

Q2.4b. How does the ancestry diagram differ from K=8? Please comment on which if any of the groups defined a priori by their ethnic/geographic origin that were split in K=8 are not split at K=6. (3 points)


### Task 3: Principal Component Analysis (PCA) of population genomic data
  
Principal Component Analysis (PCA) is a popular approach to reducing the dimensionality of 
high-dimensional data (i.e., datasets with thousands or millions of variables such as SNP data).
There are many ways to perform PCA in R including some that have been developed for PCA of 
genotype data (e.g., see the adegenet package). The smartsnp package implements the rescaling method of Patterson et al. (2006) that is meant to account for genetic drift in population genetic data.
The rescaling method adjusts SNPs based on their allele frequency in a fashion that accounts
for greater variation in high frequency alleles. This "drift" scaling is the default scaling in smart_pca function of the smartsnp package.

Here you will run PCA on genotypes from the 1,000 Genomes Project from five populations:

MKK=Maasai in Kinyawa, Kenya

YRI=Yoruba in Ibadan, Nigeria

CHB=Han Chinese in Beijing

GIH=Gujarati Indianas in Houston, Texas

CEU=Utah residents withancestry from Northern and Western Europe

Set the path to "example2.geno and example2.ind on your personal computer
```{r echo=TRUE, eval=FALSE}
pathToGenoFile <- "example2.geno"
pathToIndFile <- "example2.ind"
```

Now we will read the the .ind file as a tibble
```{r echo=TRUE, eval=FALSE}
ind_file.tbl_df <- read_delim(file=pathToIndFile,
                              col_names = FALSE,
                              delim=" ")

# Assign names to the columns (since there are none in the input file)
# note: we need the "pop" column to pass to the smart_pca function 
names(ind_file.tbl_df) <- c('sample_id','sex','pop')
```

Now run the PCA with default arguments
```{r echo=TRUE, eval=FALSE}
library(smartsnp)
pca_run1 <- smart_pca(snp_data = pathToGenoFile, sample_group = ind_file.tbl_df$pop)
```

Check what type of object is returned
```{r echo=TRUE, eval=FALSE}
class(pca_run1)
```

The PC coordinates for plotting are in the output list element "pca.sample_coordinates"
See Value section of documentation (?smart_pca)

```{r echo=TRUE, eval=FALSE}
class(pca_run1$pca.sample_coordinates)
```

Review the data.frame in the pca.sample_coordinates element of the output list
noting the dimensions of the data.frame and that by default we extracted only PC1 and PC2
```{r echo=TRUE, eval=FALSE}
pca_run1$pca.sample_coordinates %>%
  as_tibble()
```

Now lets rerun the PCA making two adjustments. First, we will compute more PC 
axes. Second, we will impute the missing genotypes (rather than removing SNPs
with one or more missing data vaues). The documentation says that imputation
is done by default (instead of removing SNPs with missing), but that's not 
the case (as can be seen by checking the the dimensions of the pca.eigenvalues 
output in first run of smart_pca vs. below. Note that normally, we would separately
impute the data with an imputation algorithm that uses LD information (rather than
the crude method used here which just takes the means of the re-scaled genotype data).

```{r echo=TRUE, eval=FALSE}
pca_run2 <- smart_pca(snp_data = pathToGenoFile, 
                   sample_group = ind_file.tbl_df$pop, 
                   pc_axes = 10,
                   missing_impute = "mean")
```

Now review
```{r echo=TRUE, eval=FALSE}
pca_run2$pca.sample_coordinates %>%
  as_tibble()
```

When conducting PCA, it is always important to report the percent of variation
explained by the first few PC axes. Recall that each PCA axis captures a successively 
smaller percentage of the variation in the the original data. How do we get this info
from smart_snp output? Check the "pca.eigenvalues" element of the output list.

```{r echo=TRUE, eval=FALSE}
pca_run2$pca.eigenvalues
```

Q3.1a How many missing data values were imputed? Hint: Check the output (in red) written to your console in the second PCA run. (2 points)

Q3.1b What is the percentage of variation explained by each of the first five PC axes? (3 points).

Q3.1c After review the variation explained in the first 10 PC axes, which axes seem to 
capture the majority of the variation before the remaining axes begin to plateau? (note: you
could make a "scree plot" with these values in a barplot with PC1 variation in explained as the leftmost
bar, PC2 as the second bar etc. if it helps visualization) (3 points)

Now plot PC1 and PC2.
```{r echo=TRUE, eval=FALSE}
ggplot(pca_run2$pca.sample_coordinates,aes(x=PC1,y=PC2,color=Group)) +
  geom_point() +
  scale_color_manual(values = c("#E69F00", "#56B4E9", "#009E73","#0072B2", "#D55E00"))
```

Q3.2a Which axis explains the largest amount of between-population variation? (2 points) 

Q3.2b Which groups of populations are most differentiated on PC1? Does
this make sense in terms of geography? (2 points)

Q3.2c Which populations are not differentiated by PC1? (2 points)

Q3.2d Are the populaions not differentiated on PC1 separated on PC2? (2 points)



#### You are finished, upload the answers either as an RMarkdown, word (.docx),.html, or .pdf via the “Assignments” section on the NYU Brightspace webpage.


